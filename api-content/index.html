{"posts":[{"title":"浅谈 WebSocket","content":"浅谈 websocket 协议 websocket 协议是 html5 的一种全双工应用层通信协议，该协议兼容常见的浏览器，基于 TCP 传输协议，并复用 HTTP 的握手通道。它可以使客户端和服务端双向数据传输变得简单快捷，并且在 TCP 连接进行一次握手后保持长久连接，允许服务器对客户端主动推送数据。另外 websocket 也支持拓展，压缩请求头节省服务器资源和宽带资源。 websocket 相关技术简介 websocket 连接的 URL 使用 ws:// 或者 wss:// 等开头，其加密、cookie 等策略和 HTTPS/HTTP 基本相同。 ws 和 wss 来进行通信协议的确定，和 HTTP 和 HTTPS 类似； ws 表示纯文本通信，wss 表示加密通道通信(TCP + TLS); 考虑到 websocket 的其他应用场景，需要自定义协议，比如保证在非 HTTP 的情况下也可以进行数据交换。 ws 协议：普通请求，占用与 HTTP 相同的 80 端口； wss 协议：基于 SSL 的安全传输，占用与 TLS 相同的 443 端口； HTTP 和 websocket 等应用层协议都是基于 TCP 协议来传输数据的，这些协议可以理解为是对 TCP 的封装。在 HTTP 协议下，客户端和服务器是单向的，服务器无法主动发送数据给客户端。而 websocket 是依赖于 HTTP 协议进行一次握手，以兼容浏览器的规范，在第一次 HTTP 请求后，后续就全部采用 TCP 通道进行双向通讯了。 3.客户端 websocket 请求与相应示例 //客户端请求 GET /chat HTTP/1.1 Host: example.com:8000 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Version: 13 //服务器相应 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Upgrade 和 Connection 表示将请求切换到 websocket 协议，Sec-WebSocket-Key 则是浏览器随机生成的 base64 编码，结合相关的算法转化后就会成为相应体中的 Sec-WebSocket-Accept 。 4.客户端使用示例 var ws = new WebSocket('ws://www.xxx.com/some.php'); ws.send('xxx'); //每次只能发送字符串 ws.onmessage = function(event) { var data = event.data; }; ws.onerror = function() { ws.close(); }; ws.send() 方法只允许发送字符串，当需要发送复杂数据时，可以结合 JSON.stringify()进行相关转化再进行数据传输。 与 websocket 类似的技术 轮询(Polling) 前端借助于 setInterval() 等方式，不断的发送请求到服务端进行数据的更新，此方法比较简单，但需要考虑轮询时间问题，时间过长会导致用户不能及时接收数据，时间过短会导致请求次数过多，增加服务器端的负担，浪费资源。 长轮询(Long Polling) 是对轮询的一种升级，客户端发出请求后，服务端用 while 等方式阻塞住请求，直到有数据才发送数据，而客户端收到相应后再发送下一个请求。 实际上是基于 HTTP 的一种慢相应；且在数据更新频繁的情况下，效率不一定优于一般的轮询。 HTTP 流(streaming) 使用 HTTP1.1 且响应头中包含Transfer-Encoding: chunked的情况下，服务端发送给客户端的数据可以分成多个部分，保持打开(while true,sleep 等)，并周期性 flush() 分块传输。 客户端只发送一个HTTP连接，在 xhr.readyState==3 状态下，用xhr.responseText.substring 获取每次的数据。 但需要注意的是这种方式会存在延迟的情况，需要额外的检测进行切换到长轮询的方式，如代理服务器或防火墙等中间人攻击造成的延迟。 流技术机制: 流技术简单的说就是客户端的页面使用一个隐藏的窗口向服务器发送一个长链接的请求，服务器接收到请求后会不断的更新数据状态，保证连接不断和信息的时效性。这种方案需兼容不同浏览器来改进用户体验，同时如果在并发情况下发生，会对服务器造成很大压力。 HTTP 判断流结束的两种方式： 1、Content-Length: 该方式适用于固定大小的数据传输中，需要在传输的数据前增加一个信息来告知对方要传输多少数据，这样在另一侧读取到这个长度的数据后就可以判断为接收已完成。 2、使用消息 Header 字段，Transfer-Encoding:chunk 如果要一边产生数据一边发送给客户端，服务器就需要使用Transfer-Encoding:chunk这样的方式来代替 Content-Length。 chunk 编码将数据分成一块一块的发生。Chunked 编码将使用若干个 Chunk 串连而成，由一个标明长度为0的 chunk 标示结束。每个 Chunk 分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开。在最后一个长度为0的 Chunk 中的内容是称为 footer 的内容，是一些附加的 Header 信息（通常可以直接忽略）。 websocket 的应用场景及优势 应用场景 1、实时性要求比较高的应用； 2、聊天室； 3、iot(物联网 - Internet of things)； 4、在线多人游戏； 优势 1、高性能： 根据测试环境数据的不同，大约会比正常的 Ajax 请求快2-10倍。HTTP 是文本协议，数据量比较大，且每次请求都会带有大量的重复请求头，传输性能较低，而 websocket 是基于二进制的协议，只在建立首次连接时用文本数据，后续请求传输的都是二进制的数据，因此性能比 Ajax 请求要高。 2、双向通信： 正常的 Ajax 请求如需获取实时数据，就需通过轮询等方式去获取数据，这样会浪费服务器的资源和流量。而通过 websocket 服务器可主动向前端发送消息。 3、建立在 TCP 协议之上，服务端实现容易。且与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器。 4、可以发送文本和二进制数据，其中二进制数据传输可优化相关的传输性能。 5、较少的控制开销。连接创建后，ws 客户端、服务器进行数据交换时，协议控制的数据包头部比较小。在不包含头部的情况下，服务端到客户端的包头只有2-10字节(取决于数据包的长度)，客户端到服务端需要加上额外的4字节的掩码。而 HTTP 每次通信都需要携带完整的头部。 如何使用 websocket 对于前端来说，使用 websocket 还是挺简单的，因为 websocket 本身就是广播-收听模式(发布-订阅)，因此前端只需要进行建立连接-监听动作-操作动作这几个步骤。 建立连接-监听动作-操作动作var ws = new WebSocket(&quot;ws://你的域名或ip&quot;); ws.onopen = function(evt) { //用于指定连接成功后的回调函数。 console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;); //用于向服务器发送数据 }; ws.onmessage = function(evt) { //收到服务器返回数据后的回调函数。 console.log( &quot;Received Message: &quot; + evt.data); ws.close(); }; ws.onclose = function(evt) { //用于连接关闭后的回调函数 console.log(&quot;Connection closed.&quot;); }; new WebSocket(&quot;ws://你的域名或ip&quot;)后返回一个 ws 的实例，简介 ws 实例属性: 1、ws.readyState属性返回实例对象的当前状态，共有四种，我们可以通过监听ws.readyState去判断socket的连接状态。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 2、ws.onerror 用于连接报错时的回调函数。一般连接报错，我们只需要执行重新连接就好了。 ws.onerror = function(event) { // handle error event ...... }; 2、服务端(Node) node中，使用最广泛的是通过ws模块来创建websocket服务，使用前需要先安装这个模块： const express = require('express'); const SocketServer = require('ws').Server; const port = 3000; const server = express().listen(port, () =&gt; { console.log(`listening to ${port}`); }) const wss = new SocketServer({server}); wss.on('connection', (ws) =&gt; { console.log('Client connected.'); ws.on('message', (data) =&gt; { console.log(data); //服务端发送数据到客户端 ws.send(data); }) ws.on('close', () =&gt; { console.log('Close connected.') }) }) 对接 websocket 时的常见问题 1、WebSocket 心跳及重连机制： WebSocket 是前后端交互的长连接，但是会存在一些特殊情况导致连接失效且相互之间没有反馈提醒，因此为了保证连接的可持续性和稳定性就产生了 WebSocket 心跳重连机制。 原生 WebSocket 服务原因导致 WebSocket 断开不会触发 WebSocket 任何事件，前端无法得知当前连接是否断开，当调用 WebSocket.send方法浏览器才发现连接断开，然后触发 onclose 函数。 后端 WebSocket 服务也可能出现异常，造成连接断开，前端也没有收到消息，因此需要前端定时发送心跳消息 ping，后端收到消息后立刻返回 pong 消息，告知连接正常，当一定时间没有 pong 消息，前端会执行重连等操作。 2、心跳检测及重连思路： 1、页面初始化，创建 WebSocket： function createWebSocket() { try { ws = new WebSocket(wsUrl); init(); } catch(e) { console.log('catch'); reconnect(wsUrl); } } 2、初始化相关监听事件： 当网络断开的时候，会先调用 onerror，onclose 事件可以监听到，会调用 reconnect 方法进行重连操作。正常的情况下，是先调用 onopen 方法的，当接收到数据时，会被 onmessage 事件监听到。 function init() { ws.onclose = function () { console.log('链接关闭'); reconnect(wsUrl); }; ws.onerror = function() { console.log('发生异常了'); reconnect(wsUrl); }; ws.onopen = function () { //心跳检测重置 heartCheck.start(); }; ws.onmessage = function (event) { //拿到任何消息都说明当前连接是正常的 console.log('接收到消息'); heartCheck.start(); } } 3、重连操作 reconnect： 如果网络断开的话，会执行 reconnect 方法，使用了一个定时器，4秒后会重新创建一个新的 websocket 链接，重新调用 createWebSocket 函数，重新会执行及发送数据给服务器端。 var lockReconnect = false;//避免重复连接 function reconnect(url) { if(lockReconnect) { return; }; lockReconnect = true; //没连接上会一直重连，设置延迟避免请求过多 tt &amp;&amp; clearTimeout(tt); tt = setTimeout(function () { createWebSocket(url); lockReconnect = false; }, 4000); } 4、心跳检测： 每隔一段固定的时间，向服务器端发送一个 ping 数据，如果在正常的情况下，服务器会返回一个 pong 给客户端，如果客户端通过 onmessage 事件能监听到的话，说明请求正常，重新心跳检测 //心跳检测 var heartCheck = { timeout: 3000, timeoutObj: null, serverTimeoutObj: null, start: function () { console.log('start'); var self = this; this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj); this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj); this.timeoutObj = setTimeout(function () { //这里发送一个心跳，后端收到后，返回一个心跳消息， //onmessage拿到返回的心跳就说明连接正常 console.log('55555'); ws.send(&quot;123456789&quot;); self.serverTimeoutObj = setTimeout(function () { console.log('reOpen',ws); ws.close(); // createWebSocket(); }, self.timeout); }, this.timeout) } } ","link":"https://Lbxin0.github.io/post/qian-tan-websocket/"},{"title":"Node 中的网络通信模块","content":"一、Socket - 可以实现底层通信，几乎所有的应用层都是通过 socket 进行通信的，因此[一切皆 socket] - 对 TCP/IP 协议进行封装，便于应用层协议进行调用，属于二者的中间抽象层； - TCP/IP 协议族中，传输层存在两种通信协议：TCP、UDP，两种协议不同，因为不同参数的 socket 实例过程也不一样； 二、net 使用 - net 模块是基于 TCP 协议的 socket 网络编程模块，http 模块就是建立在该模块的基础上实现的； ","link":"https://Lbxin0.github.io/post/node-zhong-de-wang-luo-tong-xin-mo-kuai/"},{"title":"WebSocket-socket.io 在 Node.js 中的应用","content":"一、代码案例 1、服务端 express: // socket 需要依赖于 express 建立的 HTTP 服务器 const app = require('express')(); const server = require('http').createServer(app); const io = require('socket.io')(server); io.on('connection', () =&gt; { … }); server.listen(3000); 2、客户端直接通过 socket.io-client 进行连接通讯； import io from 'socket.io-client'; window.onload = function () { var socket = io('http://localhost:3000'); // emit 向服务端发送事件， sendMsg 前后端协商事件名 后端接收事件也用这个 socket.emit('sendMsg', { text: ‘hello world’}) } 3、服务端用 on 进行事件的监听，然后相应对应数据到客户端； io.on('connection', function (socket) { // 用on监听客户端发来的事件， data即数据 socket.on('sendMsg', function (data) { // 接收到数据 后端可以做操作， 例如存入数据库中 console.log(data) // 后端再把接收到的数据返回给前端，让别人也看到， recivMgs也是定义好的事件名这个自己协商。 io.emit('recivMgs', data) }) }) 4、建立连接后，客户端监听服务器发出的事件，获取数据，渲染页面； socket.on('recivMgs', function (data) { // 做自己想做的事情 console.log(data) }) ","link":"https://Lbxin0.github.io/post/websocket-socketio-zai-nodejs-zhong-de-ying-yong/"},{"title":"socket.io 工作流程","content":"一、底层相关 socket.io 底层是engine.io，这个库实现了跨平台的双向通信。engine.io 使用了 websocket 和 XMLHttprequest（或JSONP）封装了自己的 socket协议，一个完整的 engine.io 包括多个 XHR 和 WebSocket 连接。 engine.io 协议通过一个 XHR 握手，前端发送一个 XHR，通知服务端要进行 XHR 长轮询了，服务端返回数据里包括 open 标志、sid 和 upgrades 字段。sid 相当于是 engine.io 的 SESSION ID，一次 engine.io 包含多个请求，后端又会同时连接多个 engine.io ，起身份的唯一标识；upgrades 一般为 websocket ，标识要把长轮询升级到 websocket。 engine.io 生命周期里，会间隔一定时间 ping - pong 一次，用来测试网络是否正常。 engine.io 主要处理服务端和客户端之间的各种传输和升级机制，还有断开检测功能。 engine.io-client 需要在 open 后才可以send，而 socket.io 则不需要，open 之前的 emit 的数据会在 open 之后再发送出去。 socket.io 服务端使用 ws 庫实现 websocket 协议， socket.io 服务启动时会先启动一个 ws 服务；在收到 upgrade 事件后，socket.io 会简单校验一下 websocket 相关请求，然后把请求交给 ws 服务进行处理。 socket.io 支持4种协议：WebSocket、htmlfile、xhr-polling 和 jsonp-polling 协议，它会自动根据浏览器选择合适的通讯方式，从而兼容大多数平台； 二、工作流程 在 Engine.io 连接的开始，服务器会发送一些数据信息： { 'sid': &quot;FDHSG-WEsdXXXXXXXXX&quot;, //会话 ID。必须包含在后续 HTTP 请求的 sid 查询在数中； 'upgrades': ['websopcket'], //升级数组包含服务器支持的所有更好的传输协议列表 'pingInterval': 25000, //值用于 heartbeat 机制 'pingTimeout': 20000 //值用于 heartbeat 机制 } 二、socket.io 特点 socket.io 有时候使用 WebSocket 作为传输，但它为每个数据包添加了额外的元数据，这也是为什么 WebSocket 客户端与 socket.io服务器无法相互成功连接。 socket.io 通过普通的 WebSocket 提供的功能有： 1、可靠性：如无法建立 WebSocket 连接，则回退到 HTTP 长轮询； 2、自动重连； 3、数据包缓冲：在默认情况下，socket 未连接时发出的任何事件都会被缓冲，在建立连接后再发送出去，但有时可能存在连接恢复时导致大量的事件触发，可以通过检测进行排除法触发对应事件； if (socket.connected) { socket.emit( /* ... */ ); } else { // ... } ","link":"https://Lbxin0.github.io/post/socketio-gong-zuo-liu-cheng/"},{"title":"Socket 技术简介","content":"一、Socket 简介 在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。 我的理解就是Socket就是该模式的一个实现：即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。 Socket()函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。 客户端在调用 socket() 函数创建套接字后，并没有建立连接，所以此时套接字还处于 CLOSED 的状态；服务端在调用 listen() 函数后，套接字进入 LISTEN 状态，开始监听客户端请求。 二、Socket 的断开方式 close()/closesocket() 用来关闭套接字，并在内存中将其清除，后续将无法再继续使用，而 shutdown() 则是用来关闭连接，而不是套接字，套接字在内存中还是存在； 两者都会向网络中发送 FIN 包，表示数据传输完毕，客户端收到 FIN 数据包后便认为没有数据进行传输，随后向服务端发送 ACK 包，进入 TIME_WAIT 阶段； 不同点在于 close()/closesocket() 会立即向网络中发送 FIN 包，不管缓冲区是否还有数据，会造成缓冲区数据的糗丢失，而 shutdown() 是等待缓冲区数据传输完成后再进行发送 FIN 包； 三、 Socket 常用函数接口及其原理 图解 socket 函数: 1、使用 socket() 函数创建套接字 int socket(int af, int type, int protocol); af-地址族(Address Family),即 IP 地址类型 四、前后端的交互问题 注解：在 WebSocket 出现之前，为实现即时通讯，通常采用的方案是轮询(Polling)和 Comet 技术，Comet 可细分为两种实现方式，长轮询机制和流技术，这两种技术实际是对轮询技术的改进；WebSocket 本质上是基于 tcp 的协议，由通信协议和编程 API 组成，可以在浏览器和服务器之间建立双向连接，以基于事件的方式，赋予浏览器通信的能力。 1、前后端双向消息传递的方式： 常见的是前端通过 http 进行数据请求交互，但是是单向的，如果考虑到后台向前台的数据传递就需要用到 websocket 了，常见的还有短轮询、长轮训和 websocket； 长轮训是对普通轮询的提高和改进，普通轮询就是客户端每隔一段时间就向服务器端发送请求，以频繁请求的方式进行保持客户端和服务端的数据同步，这种问题就是当服务端数据未更新的时候就会造成低效的网络传输；而长轮训在服务端数据没有更新时连接会保持一段时间的周期，直到数据或状态发生变化或连接过期，这样就会减少很多无效的客户端和服务端间的交互；当然数据改变频繁时就和普通轮询差不多了，且长轮询会占用消耗更多的资源，比如 CPU ，内存和宽带等。 websocket 首先会用 http 来建立连接，连接完成后此项服务交由 websocket 进行管理，之后会建立长久的连接； 流技术机制: 流技术简单的说就是客户端的页面使用一个隐藏的窗口向服务器发送一个长链接的请求，服务器接收到请求后悔不断的更新数据状态，保证连接不断和信息的时效性。这种方案需兼容不同浏览器来改进用户体验，同时如果在并发情况下发生，会对服务器造成很大压力。 2、HTTP 长轮询 由 HTTP 请求组成：长时间运行 GET 请求用于从服务器接收数据、短期内运行的 POST 请求，用于向服务器发送数据；由于传输的性质，连续发出的请求可能在同一个 HTTP 请求内连续被发送； 2、websocket WebSocket 是一种在服务器和浏览器之间提供全双工和低延迟通道的通信协议，socket.io 提供了客户端尝试建立 WebSocket 连接，否则将回退到 HTTP 长轮询的功能。 考虑到上述几种局限性，产生了websocket，浏览器通过 JavaScript 借助现有的 HTTP 协议来向服务器发出 WebSocket 连接的请求，当连接建立后，客户端和服务器端就可以直接通过TCP连接来直接进行数据交换。这是由于 websocket 协议本质上就是一个 TCP 连接，所以在数据传输的稳定性和传输量上有所保证，且相对于以往的轮询在性能方面也有了长足的进步。 websocket 在通信时需要借助 http ，但是他是属于双向通信协议，在建立连接后，websocket 服务端和客户端都可以主动向对方发送和接收数据，另外 websocket 需要先建立连接，只有连接后才可以进行通信。 3、websocket API new websocket(ws://localhost;9003),参数一: ws 和 wss ，参数二: 选填自定义协议，多协议使用数组； ws 和 wss 来进行通信协议的确定，和 HTTP 和 HTTPS 类似，ws 表示纯文本通信，wss 表示加密通道通信(TCP + TLS)，考虑到 websocket 的其他应用场景，需要自定义协议，比如保证在非 HTTP 的情况下也可以进行数据交换。 ws 协议：普通请求，占用与 HTTP 相同的 80 端口； wss 协议：基于 SSL 的安全传输，占用与 TLS 相同的 443 端口； HTTP 这中间设备会对 websocket 进行请求的特殊处理，比如连接的盲目升级和数据内容的随意修改等 ，wss 建立了一条端到端的安全传输通道，这个通道对中间设备模糊数据，使其无法感知到数据，也就无法对数据进行特殊处理了。 websocket 协议其实是一个 http 请求，”Upgrade:WebSocket” 表示需要将客户端的通讯协议从 http 升级到 websocket 协议，客户端到服务端的请求信息里还包括”Sec-WebSocket-Extensions”、“Sec-WebSocket-Key”这样的头信息，服务端在接收到这些握手信息后解析这些头信息，然后生成一个 28 位的安全密钥返回给客户端，表明服务器接收到了客户端的请求，同意创建 websocket 连接。 4、socket.io socket.io 是对 websocket 的封装，并且实现了服务器代码，socket.io 将 websocket 和轮询机制及通讯方式封装成了通用的接口，socket.io 简化了 websocket API ，websocket 是 socket.io 实现通讯的一个子集。 创建 socket.io 服务器需要依赖于已近创建好的 HTTP 服务器，因此需要首先创建一个 HTTP 的服务器，然后使用 socket 的 listen 方法创建一个 Socket.io 的服务器。 const socket = io.connect() 使用 socket.io 客户端和服务器端进行数据通信时有两种方式: 常规的 socket.send() 发送数据，另一端使用 socket.on('message',(data)=&gt;{}) 监听消息；另外一种方式就是通过 socket.emit('name',data,fn) 发送事件，另一端通过 socket.on('name',(name,fn)=&gt;{fn(data1,data2,...)}) 进行监听事件；在 emit 的时候可以传入多个参数，当传入函数的时候就可以实现另一端通过回调的方式调用该函数进行数据的传递； 服务端实现： // 引入socke.io const io = require('socket.io')(80) // 监听客户端连接,回调函数会传递本次连接的socket io.on('connection',function(socket)) // 给所有客户端广播消息 io.sockets.emit('String',data) // 给指定的客户端发送消息 io.sockets.socket(socketid).emit('String', data) // 监听客户端发送的信息 socket.on('String',function(data)) // 给该socket的客户端发送消息 socket.emit('String', data) Node.js API // socket-server.js // 需要使用HTTP模块来启动服务器和Socket.IO const http= require('http'), const io= require('socket.io') const server= http.createServer(function(req, res){ // 发送HTML的headers和message res.writeHead(200,{ 'Content-Type': 'text/html' }) res.end('&lt;p&gt;Hello Socket.IO!&lt;p&gt;') }); // 在8080端口启动服务器 server.listen(8080) // 创建一个Socket.IO实例，并把它传递给服务器 const socket= io.listen(server) // 添加一个连接监听器 socket.on('connection', function(client) { // 连接成功，开始监听 client.on('message',function(event){ console.log('Received message from client!',event) }) // 连接失败 client.on('disconnect',function(){ clearInterval(interval) console.log('Server has disconnected') }) }) ","link":"https://Lbxin0.github.io/post/socket-ji-zhu-xiang-jie/"},{"title":"在 React 中使用 TypeScript；","content":" 组件声明 1、类组件： React.Component&lt;P, S={}&gt; 和 React.PureComponent&lt;P, S={} SS={}&gt;; import React, {PureComponent, Component} from &quot;react&quot;; interface propsType { name: string } interface stateType { id: number } ...... class App extends React.Component&lt;propsType, stateType&gt;{ ...... } class App React.PureComponent&lt;propsType, stateType&gt;{ ...... } React.Component 和 React.PureComponent 的区别在于 PureComponent 在 shouldComponentUpdate 只进行浅层的比较，只要外层的对象不发生变化就不会触发 render，减少了不必要的 virtual DOM 的 diff 和重新生成的过程，但缺点就是不适合在含有多层嵌套对象的 state 和 props 中(数据嵌套导致页面得不到更新)，像表单等复杂组件中，将组件拆分成简单的 PureComponent，使得组件变得易于维护；而 Component 父组件的 state 和 props 更新时，子组件都会更新，浪费性能。 如果在定义组件的时候不确定组件的props类型，只有在调用的时候才知道组件类型，就可以用泛型进行组建的定义了。 class MyComponent&lt;P&gt; extends React.Component&lt;P&gt; { internalProp: P; constructor(props: P) { super(props); this.internalProp = props; } render() { return ( &lt;span&gt;hello world&lt;/span&gt; ); } } // 使用组件 type IProps = { name: string; age: number; }; &lt;MyComponent&lt;IProps&gt; name=&quot;React&quot; age={18} /&gt;; // Success &lt;MyComponent&lt;IProps&gt; name=&quot;TypeScript&quot; age=&quot;hello&quot; /&gt;; // Error 2、函数组件 书写方式有直接函数声明的方式和 React.FunctionComponent/React.FC&lt;P={}&gt; 来定义； `type React.FC&lt;P = {}&gt; = React.FunctionComponent&lt;P&gt;` import Child1 from &quot;./child1&quot;; import Child2 from &quot;./child2&quot;; interface IProps { name: string; } const App: React.FC&lt;IProps&gt; = (props) =&gt; { const { name } = props; return ( &lt;Child1 name={name}&gt; &lt;Child2 name={name} /&gt; TypeScript &lt;/Child1&gt; ); }; export default App; // 其中 cheild1 组件的 props 中有 name 和 children 的属性，children 是一个数组，包含了 child2 对象和后面的文本； 当使用箭头函数的方式进行定义的时候需要注意必须使用 extends 关键字来定义泛型参数才可以被解析成功； const MyComponent = &lt;P extends any&gt;(props: P) { return ( &lt;span&gt; {props} &lt;/span&gt; ); } // 普通函数 function MyComponent&lt;P&gt;(props: P) { return ( &lt;span&gt; {props} &lt;/span&gt; ); } // 使用组件 type IProps = { name: string; age: number; }; &lt;MyComponent&lt;IProps&gt; name=&quot;React&quot; age={18} /&gt;; // Success &lt;MyComponent&lt;IProps&gt; name=&quot;TypeScript&quot; age=&quot;hello&quot; /&gt;; // Error 3、react 内置类型简介 JSX.Element 是 ReactElement 的子类型，没有添加属性，两者是等价的，可以相互赋值； JSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得： const jsx = &lt;div&gt;Lbxin&lt;/div&gt; const ele = React.createElement(&quot;div&quot;, null, &quot;Lbxin&quot;); 4、React Hooks useState: 默认情况下 React 会根据 statue 的初始值进行自动推断 statue 和更新函数的类型； const [count, setCount] = useState&lt;number&gt;(1) //已知 state 的类型； const [count, setCount] = useState&lt;number | null&gt;(null); ` //初始值为 null 则需显示的设置 state 的类型； const [user, setUser] = React.useState&lt;IUser&gt;({} as IUser);//初始化为空对象则需断言处理，断言处理是为了避免后续的代码依赖这个对象，所以在使用前进行断言初始化 user 的值，否则会报错； ","link":"https://Lbxin0.github.io/post/zai-react-zhong-shi-yong-typescript/"}]}